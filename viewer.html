<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Viewer Live</title>
    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background: #000;
        color: white;
        height: 100vh;
        overflow: hidden;
        position: relative;
      }
      
      /* Fullscreen video container */
      #video-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
      }
      
      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      audio {
        display: none;
      }
      
      .placeholder {
        color: rgba(255, 255, 255, 0.8);
        font-size: 24px;
        text-align: center;
        background: rgba(0, 0, 0, 0.7);
        padding: 40px;
        border-radius: 15px;
        backdrop-filter: blur(10px);
      }
      
      /* Popup overlays */
      .overlay {
        position: fixed;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 400px;
        animation: slideIn 0.3s ease-out;
      }
      
      @keyframes slideIn {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      /* Top overlay for connection status */
      .status-overlay {
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        min-width: 300px;
      }
      
      /* Error popup */
      .error-popup {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(244, 67, 54, 0.9);
        border: 1px solid #f44336;
        animation: shake 0.5s ease-in-out;
      }
      
      @keyframes shake {
        0%, 100% { transform: translate(-50%, -50%); }
        25% { transform: translate(-52%, -50%); }
        75% { transform: translate(-48%, -50%); }
      }
      
      /* Loading popup */
      .loading-popup {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(33, 150, 243, 0.9);
        border: 1px solid #2196f3;
        text-align: center;
      }
      
      /* Participants popup */
      .participants-popup {
        top: 20px;
        right: 20px;
        background: rgba(76, 175, 80, 0.9);
        border: 1px solid #4caf50;
        max-width: 250px;
      }
      
      /* Controls popup */
      .controls-popup {
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(156, 39, 176, 0.9);
        border: 1px solid #9c27b0;
        text-align: center;
      }
      
      .status-badge {
        display: inline-block;
        padding: 8px 16px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        margin: 5px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      
      .status-connecting { 
        background: linear-gradient(45deg, #ff9800, #f57c00); 
        color: white;
      }
      .status-connected { 
        background: linear-gradient(45deg, #4caf50, #388e3c); 
        color: white;
      }
      .status-error { 
        background: linear-gradient(45deg, #f44336, #d32f2f); 
        color: white;
      }
      .status-disconnected { 
        background: linear-gradient(45deg, #9e9e9e, #616161); 
        color: white;
      }
      
      button {
        background: linear-gradient(45deg, #f44336, #d32f2f);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        margin: 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
      }
      
      button:active {
        transform: translateY(0);
      }
      
      .participant {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        padding: 6px 12px;
        border-radius: 15px;
        margin: 3px;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      
      .spinner {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 3px solid #fff;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 10px;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      /* Auto-hide overlays */
      .auto-hide {
        opacity: 0.7;
        transition: opacity 0.3s ease;
      }
      
      .auto-hide:hover {
        opacity: 1;
      }
      
      /* Info text */
      .info-text {
        font-size: 12px;
        margin-top: 10px;
        color: rgba(255, 255, 255, 0.8);
      }
      
      h3 {
        margin: 0 0 10px 0;
        font-size: 16px;
        font-weight: bold;
      }
      
      /* Hide scrollbars */
      ::-webkit-scrollbar {
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Fullscreen video container -->
    <div id="video-container">
      <div class="placeholder">üì∫ ƒêang ch·ªù video stream...</div>
    </div>

    <!-- Connection Status Overlay (Top Center) -->
    <div id="status-overlay" class="overlay status-overlay auto-hide">
      <h3>üì° Connection Status</h3>
      <div>
        <span class="status-badge" id="connection-status">ƒêang kh·ªüi t·∫°o...</span>
      </div>
      <div class="info-text">
        <strong>Room:</strong> <span id="room-display">-</span><br>
        <strong>Identity:</strong> <span id="identity-display">-</span>
      </div>
    </div>

    <!-- Loading Popup (Center) -->
    <div id="loading-popup" class="overlay loading-popup" style="display: none;">
      <div class="spinner"></div>
      <span>ƒêang k·∫øt n·ªëi ƒë·∫øn livestream...</span>
    </div>

    <!-- Error Popup (Center) -->
    <div id="error-popup" class="overlay error-popup" style="display: none;">
      <h3>‚ùå L·ªói k·∫øt n·ªëi</h3>
      <div id="error-message"></div>
      <button onclick="hideErrorPopup()" style="margin-top: 15px;">ƒê√≥ng</button>
    </div>

    <!-- Participants Popup (Top Right) -->
    <div id="participants-popup" class="overlay participants-popup auto-hide" style="display: none;">
      <h3>üë• Participants</h3>
      <div id="participant-list"></div>
    </div>
      
    <!-- Controls Popup (Bottom Center) -->
    <div id="controls-popup" class="overlay controls-popup auto-hide" style="display: none;">
      <button id="unmute-btn" onclick="unmuteAudio()" style="display: none; background: linear-gradient(45deg, #ff9800, #f57c00); margin-right: 10px;">üîä B·∫≠t √¢m thanh</button>
      <button onclick="confirmDisconnect()">üö™ R·ªùi kh·ªèi stream</button>
    </div>

    <script>
      const wsUrl = "wss://wslive.loltips.net";
      let currentRoom = null;
      let audioElements = []; // L∆∞u tr·ªØ c√°c audio elements ƒë·ªÉ qu·∫£n l√Ω

      // L·∫•y query params t·ª´ URL
      function getQuery(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
      }

      // C·∫≠p nh·∫≠t status
      function updateConnectionStatus(status, type = 'connecting') {
        const statusElement = document.getElementById('connection-status');
        statusElement.textContent = status;
        statusElement.className = `status-badge status-${type}`;
      }

      // Hi·ªÉn th·ªã l·ªói popup
      function showError(message) {
        const errorPopup = document.getElementById('error-popup');
        const errorMessage = document.getElementById('error-message');
        errorMessage.innerHTML = `
          <div style="margin-bottom: 15px;">${message}</div>
          <button onclick="retryConnection()" style="background: linear-gradient(45deg, #4CAF50, #388e3c); margin-right: 10px;">üîÑ Th·ª≠ l·∫°i</button>
        `;
        errorPopup.style.display = 'block';
      }

      // ·∫®n error popup
      function hideErrorPopup() {
        document.getElementById('error-popup').style.display = 'none';
      }

      // Th·ª≠ k·∫øt n·ªëi l·∫°i
      function retryConnection() {
        hideErrorPopup();
        startViewing();
      }

      // Hi·ªÉn th·ªã loading popup
      function showLoading(show = true) {
        document.getElementById('loading-popup').style.display = show ? 'block' : 'none';
      }

      // Hi·ªÉn th·ªã/·∫©n participants popup
      function toggleParticipants(show = true) {
        document.getElementById('participants-popup').style.display = show ? 'block' : 'none';
      }

      // Hi·ªÉn th·ªã/·∫©n controls popup
      function toggleControls(show = true) {
        document.getElementById('controls-popup').style.display = show ? 'block' : 'none';
      }

      // C·∫≠p nh·∫≠t th√¥ng tin room
      function updateRoomInfo(roomId, identity) {
        document.getElementById('room-display').textContent = roomId || '-';
        document.getElementById('identity-display').textContent = identity || '-';
      }

      // Hi·ªÉn th·ªã n√∫t unmute khi browser ch·∫∑n autoplay audio
      function showUnmuteButton(audioElement) {
        const unmuteBtn = document.getElementById('unmute-btn');
        unmuteBtn.style.display = 'inline-block';
        
        // L∆∞u audio element ƒë·ªÉ unmute sau
        if (!audioElements.includes(audioElement)) {
          audioElements.push(audioElement);
        }
        
        console.log('üîá Audio autoplay blocked - showing unmute button');
      }

      // H√†m unmute audio khi user click
      function unmuteAudio() {
        audioElements.forEach(audioElement => {
          if (audioElement && audioElement.paused) {
            const playPromise = audioElement.play();
            if (playPromise !== undefined) {
              playPromise.then(() => {
                console.log('üîä Audio resumed successfully after user interaction');
              }).catch(error => {
                console.error('‚ùå Failed to resume audio:', error);
              });
            }
          }
        });
        
        // ·∫®n n√∫t unmute sau khi b·∫≠t
        const unmuteBtn = document.getElementById('unmute-btn');
        unmuteBtn.style.display = 'none';
      }

      // H√†m ki·ªÉm tra v√† kh·ªüi t·∫°o audio context n·∫øu c·∫ßn
      function initAudioContext() {
        // T·∫°o AudioContext ƒë·ªÉ ƒë·∫£m b·∫£o Web Audio API ho·∫°t ƒë·ªông
        if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
          const AudioContextClass = AudioContext || webkitAudioContext;
          if (!window.audioContext) {
            window.audioContext = new AudioContextClass();
            
            if (window.audioContext.state === 'suspended') {
              window.audioContext.resume().then(() => {
                console.log('üéµ AudioContext resumed successfully');
              });
            }
          }
        }
      }

      // C·∫≠p nh·∫≠t danh s√°ch participants
      function updateParticipants() {
        if (!currentRoom || !currentRoom.localParticipant) return;
        
        try {
          const participantList = document.getElementById('participant-list');
          if (!participantList) return;
          
          participantList.innerHTML = '';
          
          // Add local participant
          const localEl = document.createElement('div');
          localEl.className = 'participant';
          localEl.textContent = `${currentRoom.localParticipant.identity || 'Viewer'} (You)`;
          participantList.appendChild(localEl);
          
          // Add remote participants
          if (currentRoom.participants) {
            currentRoom.participants.forEach(participant => {
              const participantEl = document.createElement('div');
              participantEl.className = 'participant';
              participantEl.textContent = participant.identity || 'Unknown';
              participantList.appendChild(participantEl);
            });
          }
          
          // Show participants popup if there are participants
          const totalParticipants = 1 + (currentRoom.participants ? currentRoom.participants.size : 0);
          if (totalParticipants > 1) {
            toggleParticipants(true);
          }
        } catch (err) {
          console.error('‚ùå Error updating participants:', err);
        }
      }

      // B·∫Øt ƒë·∫ßu xem livestream
      async function startViewing() {
        const roomId = getQuery('room');
        let token = getQuery('token');

        if (!roomId) {
          showError('URL kh√¥ng h·ª£p l·ªá! Thi·∫øu room parameter.<br>URL ƒë√∫ng: viewer.html?room=ROOM_ID');
          updateConnectionStatus('L·ªói URL', 'error');
          return;
        }

        // N·∫øu kh√¥ng c√≥ token trong URL, l·∫•y t·ª´ API
        if (!token) {
          try {
            updateConnectionStatus('ƒêang l·∫•y token...', 'connecting');
            const response = await fetch(`/api/v1/stream/token?room=${roomId}&identity=viewer_${Date.now()}&role=viewer`);
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            token = data.token;
            
            if (!token) {
              throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c token t·ª´ server');
            }
          } catch (err) {
            console.error('‚ùå Token fetch error:', err);
            let errorMessage = 'Kh√¥ng th·ªÉ l·∫•y token t·ª´ server';
            
            if (err.message.includes('404')) {
              errorMessage = 'üè† Room kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë√≥ng';
            } else if (err.message.includes('403')) {
              errorMessage = 'üö´ Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p room n√†y';
            } else if (err.message.includes('500')) {
              errorMessage = 'üîß L·ªói server, vui l√≤ng th·ª≠ l·∫°i sau';
            }
            
            showError(`${errorMessage}<br><small>Chi ti·∫øt: ${err.message}</small>`);
            updateConnectionStatus('L·ªói token', 'error');
            return;
          }
        }

        try {
          updateConnectionStatus('ƒêang k·∫øt n·ªëi...', 'connecting');
          showLoading(true);
          hideErrorPopup();
          
          // Ng·∫Øt k·∫øt n·ªëi c≈© n·∫øu c√≥
          if (currentRoom) {
            await currentRoom.disconnect();
          }

          // T·∫°o room m·ªõi
          currentRoom = new LivekitClient.Room();

          // ƒêƒÉng k√Ω c√°c event handlers - Fixed cho camera toggle
          currentRoom.on('trackSubscribed', (track, publication, participant) => {
            console.log('üì∫ Track subscribed:', track.kind, 'from', participant.identity);
            
            if (track.kind === 'video') {
              console.log('üìπ Video track received, attaching to viewer...');
              
              const videoElement = track.attach();
              videoElement.style.width = '100%';
              videoElement.style.height = '100%';
              videoElement.style.objectFit = 'cover';
              videoElement.autoplay = true;
              videoElement.playsInline = true;
              
              const videoContainer = document.getElementById('video-container');
              videoContainer.innerHTML = '';
              videoContainer.appendChild(videoElement);
              
              console.log('‚úÖ Video element attached and playing');
              
            } else if (track.kind === 'audio') {
              console.log('üîä Audio track received, setting up audio...');
              
              const audioElement = track.attach();
              // ƒê·∫£m b·∫£o audio c√≥ th·ªÉ ph√°t ƒë∆∞·ª£c theo Chrome Autoplay Policy
              audioElement.muted = false; 
              audioElement.autoplay = true;
              audioElement.style.display = 'none';
              
              // Th·ª≠ ph√°t audio ngay sau khi attach
              const playPromise = audioElement.play();
              if (playPromise !== undefined) {
                playPromise.then(() => {
                  console.log('üîä Audio autoplay started successfully');
                }).catch(error => {
                  console.warn('üîá Audio autoplay prevented by browser, showing unmute button');
                  showUnmuteButton(audioElement);
                });
              }
              
              document.body.appendChild(audioElement);
            }
          });

          currentRoom.on('trackUnsubscribed', (track, publication, participant) => {
            console.log('‚ùå Track unsubscribed:', track.kind, 'from', participant.identity);
            
            if (track.kind === 'video') {
              console.log('üìπ Video track removed, showing placeholder...');
              
              // Detach video elements
              const detachedElements = track.detach();
              detachedElements.forEach(element => {
                if (element.parentNode) {
                  element.parentNode.removeChild(element);
                }
              });
              
              // Show placeholder for video
              const videoContainer = document.getElementById('video-container');
              videoContainer.innerHTML = '<div class="placeholder">üìπ Streamer ƒë√£ t·∫Øt camera<br><small>Ch·ªù streamer b·∫≠t l·∫°i...</small></div>';
              
            } else if (track.kind === 'audio') {
              console.log('üîä Audio track removed...');
              
              const detachedElements = track.detach();
              detachedElements.forEach(element => {
                // Remove t·ª´ audioElements array
                const index = audioElements.indexOf(element);
                if (index > -1) {
                  audioElements.splice(index, 1);
                }
                // Remove t·ª´ DOM
                if (element.parentNode) {
                  element.parentNode.removeChild(element);
                }
              });
            } else {
              // Other track types
              track.detach();
            }
          });

          currentRoom.on('participantConnected', (participant) => {
            console.log('üë§ Participant connected:', participant.identity);
            updateParticipants();
          });

          // Th√™m handlers cho track mute/unmute events
          currentRoom.on('trackMuted', (publication, participant) => {
            console.log(`üîá Track muted: ${publication.kind} from ${participant.identity}`);
            
            if (publication.kind === 'video') {
              const videoContainer = document.getElementById('video-container');
              videoContainer.innerHTML = '<div class="placeholder">üìπ Video ƒë√£ b·ªã t·∫Øt<br><small>Streamer ƒë√£ mute video</small></div>';
            }
          });

          currentRoom.on('trackUnmuted', (publication, participant) => {
            console.log(`üîä Track unmuted: ${publication.kind} from ${participant.identity}`);
            
            if (publication.kind === 'video' && publication.track) {
              console.log('üìπ Video track unmuted, re-attaching...');
              
              const videoElement = publication.track.attach();
              videoElement.style.width = '100%';
              videoElement.style.height = '100%';
              videoElement.style.objectFit = 'cover';
              videoElement.autoplay = true;
              videoElement.playsInline = true;
              
              const videoContainer = document.getElementById('video-container');
              videoContainer.innerHTML = '';
              videoContainer.appendChild(videoElement);
            }
          });

          // Th√™m handlers cho track published/unpublished events
          currentRoom.on('trackPublished', (publication, participant) => {
            console.log(`üì§ Track published: ${publication.kind} from ${participant.identity}`);
            
            // Track s·∫Ω ƒë∆∞·ª£c auto-subscribe n·∫øu autoSubscribe enabled
            if (publication.kind === 'video') {
              console.log('üìπ New video track available, waiting for subscription...');
            }
          });

          currentRoom.on('trackUnpublished', (publication, participant) => {
            console.log(`üì§ Track unpublished: ${publication.kind} from ${participant.identity}`);
            
            if (publication.kind === 'video') {
              console.log('üìπ Video track unpublished, showing placeholder...');
              const videoContainer = document.getElementById('video-container');
              videoContainer.innerHTML = '<div class="placeholder">üìπ Streamer ƒë√£ t·∫Øt camera<br><small>Ch·ªù streamer b·∫≠t l·∫°i...</small></div>';
            }
          });

          currentRoom.on('participantDisconnected', (participant) => {
            console.log('üëã Participant disconnected:', participant.identity);
            updateParticipants();
            
            // Ki·ªÉm tra n·∫øu kh√¥ng c√≤n streamer n√†o (ch·ªâ c√≤n viewer) - delay ƒë·ªÉ ƒë·∫£m b·∫£o state ƒë√£ update
            setTimeout(() => {
              checkStreamStatus();
            }, 2000);
          });

          currentRoom.on('disconnected', () => {
            console.log('‚ùå Disconnected from livestream');
            updateConnectionStatus('ƒê√£ ng·∫Øt k·∫øt n·ªëi', 'disconnected');
            resetUI();
            
            // T·ª± ƒë·ªông quay v·ªÅ trang tr∆∞·ªõc khi b·ªã ng·∫Øt k·∫øt n·ªëi
            setTimeout(() => {
              goBackOrClose();
            }, 2000); // Delay 2 gi√¢y ƒë·ªÉ user th·∫•y th√¥ng b√°o
          });

          currentRoom.on('connectionStateChanged', (state) => {
            console.log('üîÑ Connection state:', state);
            if (state === 'connected') {
              updateConnectionStatus('ƒê√£ k·∫øt n·ªëi', 'connected');
              showLoading(false);
              hideErrorPopup(); // ·∫®n error popup khi k·∫øt n·ªëi th√†nh c√¥ng
              toggleControls(true);
              
              // Kh·ªüi t·∫°o AudioContext sau khi k·∫øt n·ªëi th√†nh c√¥ng
              initAudioContext();
            } else if (state === 'connecting') {
              updateConnectionStatus('ƒêang k·∫øt n·ªëi...', 'connecting');
            } else if (state === 'disconnected') {
              updateConnectionStatus('ƒê√£ ng·∫Øt k·∫øt n·ªëi', 'disconnected');
              toggleControls(false);
            }
          });

          // K·∫øt n·ªëi ƒë·∫øn room
          await currentRoom.connect(wsUrl, token);
          
          // C·∫≠p nh·∫≠t UI
          updateRoomInfo(roomId, currentRoom.localParticipant.identity);
          updateParticipants();
          
        } catch (err) {
          console.error('‚ùå Connection error:', err);
          showLoading(false);
          
          let errorMessage = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn livestream';
          if (err.message.includes('token')) {
            errorMessage = 'üîë Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n';
          } else if (err.message.includes('room')) {
            errorMessage = 'üè† Room kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë√≥ng';
          } else if (err.message.includes('websocket') || err.message.includes('WebSocket')) {
            errorMessage = 'üåê Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server LiveKit';
          }
          
          showError(`${errorMessage}<br><small>Chi ti·∫øt: ${err.message}</small>`);
          updateConnectionStatus('L·ªói k·∫øt n·ªëi', 'error');
        }
      }

      // X√°c nh·∫≠n tr∆∞·ªõc khi r·ªùi kh·ªèi stream
      function confirmDisconnect() {
        const shouldLeave = confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën r·ªùi kh·ªèi livestream kh√¥ng?');
        if (shouldLeave) {
          disconnectStream();
        }
      }

      // Ng·∫Øt k·∫øt n·ªëi v√† quay v·ªÅ trang tr∆∞·ªõc ho·∫∑c ƒë√≥ng tab
      async function disconnectStream() {
        try {
          if (currentRoom) {
            await currentRoom.disconnect();
            currentRoom = null;
          }
          updateConnectionStatus('ƒê√£ ng·∫Øt k·∫øt n·ªëi', 'disconnected');
          resetUI();
          
          // Quay v·ªÅ trang tr∆∞·ªõc ho·∫∑c ƒë√≥ng tab
          await goBackOrClose();
        } catch (err) {
          console.error('‚ùå Disconnect error:', err);
          // V·∫´n th·ª≠ quay v·ªÅ trang tr∆∞·ªõc n·∫øu c√≥ l·ªói
          await goBackOrClose();
        }
      }

      // Ki·ªÉm tra tr·∫°ng th√°i stream v√† t·ª± ƒë·ªông k·∫øt th√∫c n·∫øu kh√¥ng c√≤n streamer
      function checkStreamStatus() {
        if (!currentRoom || !currentRoom.participants) return;
        
        try {
          // ƒê·∫øm s·ªë participants c√≥ track video (streamer)
          let activeStreamers = 0;
          let hasVideoTracks = false;
          
          currentRoom.participants.forEach(participant => {
            if (participant.tracks && participant.tracks.size > 0) {
              const hasVideo = Array.from(participant.tracks.values()).some(
                trackPub => trackPub.track && trackPub.track.kind === 'video' && trackPub.isSubscribed
              );
              if (hasVideo) {
                activeStreamers++;
                hasVideoTracks = true;
              }
            }
          });
          
          console.log(`üë• Participants: ${currentRoom.participants.size}, Active streamers: ${activeStreamers}`);
          
          // Ch·ªâ k·∫øt th√∫c stream n·∫øu:
          // 1. Kh√¥ng c√≥ participants n√†o HO·∫∂C
          // 2. Kh√¥ng c√≥ video tracks n√†o v√† ƒë√£ k·∫øt n·ªëi ƒë∆∞·ª£c √≠t nh·∫•t 10 gi√¢y
          const isConnectedLongEnough = currentRoom.state === 'connected';
          
          if (isConnectedLongEnough && currentRoom.participants.size === 0) {
            console.log('üì∫ Livestream ƒë√£ k·∫øt th√∫c - kh√¥ng c√≤n participants');
            endLivestream();
          }
        } catch (err) {
          console.error('‚ùå Error checking stream status:', err);
        }
      }

      // K·∫øt th√∫c livestream v·ªõi th√¥ng b√°o
      function endLivestream() {
        updateConnectionStatus('Livestream ƒë√£ k·∫øt th√∫c', 'disconnected');
        
        // Hi·ªÉn th·ªã th√¥ng b√°o k·∫øt th√∫c
        showError(`
          <div style="background: rgba(255, 193, 7, 0.9); color: #000; padding: 15px; border-radius: 10px; margin-bottom: 15px;">
            üì∫ <strong>Livestream ƒë√£ k·∫øt th√∫c</strong><br>
            <small>Streamer ƒë√£ r·ªùi kh·ªèi ph√≤ng</small>
          </div>
          <div>T·ª± ƒë·ªông quay v·ªÅ trang tr∆∞·ªõc sau <span id="countdown">5</span> gi√¢y...</div>
        `);
        
        // ƒê·∫øm ng∆∞·ª£c v√† t·ª± ƒë·ªông quay v·ªÅ
        let countdown = 5;
        const countdownInterval = setInterval(() => {
          countdown--;
          const countdownEl = document.getElementById('countdown');
          if (countdownEl) {
            countdownEl.textContent = countdown;
          }
          
          if (countdown <= 0) {
            clearInterval(countdownInterval);
            hideErrorPopup();
            goBackOrClose();
          }
        }, 1000);
      }

      // H√†m quay v·ªÅ trang tr∆∞·ªõc ho·∫∑c ƒë√≥ng tab
      async function goBackOrClose() {
        try {
          // Ki·ªÉm tra xem c√≥ th·ªÉ quay v·ªÅ trang tr∆∞·ªõc kh√¥ng
          if (window.history.length > 1 && document.referrer) {
            // C√≥ l·ªãch s·ª≠ v√† c√≥ trang tr∆∞·ªõc, quay v·ªÅ
            window.history.back();
          } else {
            // Kh√¥ng c√≥ trang tr∆∞·ªõc, th·ª≠ ƒë√≥ng tab
            // Hi·ªÉn th·ªã th√¥ng b√°o tr∆∞·ªõc khi ƒë√≥ng
            const shouldClose = confirm('Livestream ƒë√£ k·∫øt th√∫c. B·∫°n c√≥ mu·ªën ƒë√≥ng tab n√†y kh√¥ng?');
            if (shouldClose) {
              window.close();
            }
          }
        } catch (err) {
          console.error('‚ùå Navigation error:', err);
          // Fallback: reload trang ch·ªß ho·∫∑c hi·ªÉn th·ªã th√¥ng b√°o
          alert('Livestream ƒë√£ k·∫øt th√∫c. Vui l√≤ng ƒë√≥ng tab n√†y.');
        }
      }

      // Reset UI v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
      function resetUI() {
        document.getElementById('video-container').innerHTML = '<div class="placeholder">üì∫ ƒêang ch·ªù video stream...</div>';
        toggleParticipants(false);
        toggleControls(false);
        showLoading(false);
        document.getElementById('participant-list').innerHTML = '';
      }

      // Auto-start khi trang load
      window.onload = () => {
        const roomId = getQuery('room');
        
        if (roomId) {
          updateRoomInfo(roomId, 'ƒêang chu·∫©n b·ªã...');
          setTimeout(startViewing, 500); // Delay nh·ªè ƒë·ªÉ UI render
        } else {
          showError('URL kh√¥ng h·ª£p l·ªá! Thi·∫øu room parameter.<br><strong>URL ƒë√∫ng:</strong> viewer.html?room=ROOM_ID');
          updateConnectionStatus('L·ªói URL', 'error');
        }
      };

      // Cleanup khi tho√°t trang
      window.addEventListener('beforeunload', () => {
        if (currentRoom) {
          currentRoom.disconnect();
        }
      });

      // Add user interaction listener ƒë·ªÉ enable audio
      document.addEventListener('click', () => {
        initAudioContext();
      }, { once: true }); // Ch·ªâ ch·∫°y 1 l·∫ßn

      // Add touch event cho mobile
      document.addEventListener('touchstart', () => {
        initAudioContext();
      }, { once: true });
    </script>
  </body>
</html>

